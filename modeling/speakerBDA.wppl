// run using:
// webppl speakerBDA.wppl --require ./refModule/

// Fix some configuration options
var globalConfig = {
  'storePredictives' : false,
  'outputFileName' : 'testing'
};

// Load in data & conditions
var data = refModule.readCSV("./bdaInput/speaker-cassette-only.csv");
var conditions = refModule.readCSV("./bdaInput/conditions-cassette-only.csv");

var modelAnalysis = function() {
  // Sample params (and eventually model, for model comparison)
  var model = uniformDraw(['egocentric', 'uncertainRSA']); // 'visualAccess', 'weighted'
  var alpha = Number.parseFloat(uniformDraw(_.range(0, 5, .1)));
  console.log(alpha)
  var params = {
    model, alpha,
    costWeight : Number.parseFloat(uniformDraw(_.range(0,.3,0.02)).toFixed(3)),
    typWeight : (model === 'egocentric' ? 0 :
		 Number.parseFloat(uniformDraw(_.range(.5, 5, .25)))),
    perspectiveWeight : (model === 'weighted' ?
			 Number.parseFloat(uniformDraw(_.range(0, 1.01, 0.25))) : 0),
    omniscienceProb: 1//(model === 'uncertainRSA' ?
		     // Number.parseFloat(uniformDraw(_.range(0, 1, 0.1))) : 0)
  };
  var lexicon = refModule.constructLexicon(params);
  
  var score = map(function(conditionObj) {
    // Extract condition information
    var conditionName = conditionObj.conditionName;
    var context = {shared: [conditionObj.target, 'other1', 'other2'],
		   occluded: [conditionObj.distractor]};
    // Run model
    var modelOutput = speakerModel(context.shared[0], context, extend(params, {
      lexicon : lexicon
    }));
    
    // Store predives
    // if(globalConfig.storePredictives) {
    //   foreach(modelOutput.support(), function(s){
    // 	var key = _.values(conditionObj).concat(s);
    // 	var newPair = _.zipObject([key], [Math.exp(modelOutput.score(s))]);
    // 	globalStore.predictives = extend(globalStore.predictives, newPair);
    //   });
    // }
    
    // condition on data
    var itemData = refModule.getSubset(data, {objectSet: conditionObj.objectSet});
    return reduce(function(datum, memo) {
      return modelOutput.score(datum.label) + memo;
    }, 0, itemData);
  }, conditions);

  console.log(params);
  console.log(score);

  factor(sum(score));

  var paramsKey = _.values(params).join(',');
  return {predictive: globalStore.predictives, params : _.zipObject([paramsKey], [sum(score)])};
};

//var outputERP = Infer({method:'MCMC', kernel: 'HMC', samples: 500, lag: 2, burn: 100, verbose: true, model: modelAnalysis});

var outputERP = Infer({method: 'enumerate', model: modelAnalysis})

//console.log(outputERP);
refModule.bayesianErpWriter(outputERP, "./bdaOutput/" + globalConfig.outputFileName);
console.log('done writing: results in ' + globalConfig.outputFileName);
