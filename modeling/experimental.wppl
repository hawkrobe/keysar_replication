///fold:
var possibleUtterances = [
  'shape', 'color', 'texture', 'texture_color', 'color_shape', 'texture_shape', 'texture_color_shape'
];

// hand-coded to match stimulus set used in experiment
var possibleObjects = Categorical({
  vs: ['texture_color_shape', 'otherTexture_color_shape', 'texture_otherColor_shape',
       'otherTexture_otherColor_shape', 'texture_color_otherShape', 'texture_otherColor_otherShape',
       'otherTexture_color_otherShape', 'otherTexture_otherColor_otherShape'],
  ps: [1/64, 3/64, 3/64, 9/64, 3/64, 9/64, 9/64, 27/64]
});

var params = {
  alpha: 10,
  textureCost : .1,
  shapeCost : 0.1,
  colorCost : 0.1,
  perspectiveCost : 0
}

var contexts = {
  'diff_shape' : ['texture_color_shape', 'otherTexture_otherColor_otherShape'],
  'shape_only' : ['texture_color_shape', 'otherTexture_otherColor_shape'],
  'color_shape' : ['texture_color_shape', 'otherTexture_color_shape'],
  'texture_shape' : ['texture_color_shape', 'texture_otherColor_shape']
};

var uttFitness = function(utt, object) {
  var descriptors = utt.split('_');
  var objProperties = object.split('_').slice(0,3);
  var matches = _.every(map(function(descriptor) {
    return _.includes(objProperties, descriptor);
  }, descriptors));
  return matches ? 0 : -100;
};

var uttCost = function(utt) {
  var descriptors = utt.split('_');
  return sum(map(function(descriptor) {
    return descriptor == 'null' ? 0 : params[descriptor + 'Cost'];
  }, descriptors));
};
//

var getListenerUtility = function(partnerLevel, utt, target, context) {
  return marginalize(S(partnerLevel, target, context), function(x) {return x.utt}).score(utt)
}

var L = function(level, weighting, utt, context) {
  return Infer({method: 'enumerate'}, function() {
    
    // Marginalized
    var perspective = flip(weighting) ? 'own' : 'other';
    var partnerContext = perspective == 'own' ? context : remove(find(function(x) {return last(x) == '2'}, context), context);
    var object = uniformDraw(partnerContext);
    var utility = (
      level == 0 ? uttFitness(utt, object) : 
      marginalize(S(0, object, context), function(x) {return x.utt}).score(utt)
    );
    factor(utility);
    return object;
  });
};


var getSpeakerUtility = function(perspective, partnerLevel, partnerWeighting, 
                                  utt, target, context) {
  if(perspective == 'own') {
//     print(utt)
//     viz.table(L(partnerLevel, partnerWeighting, utt, context))
    return params.alpha * L(partnerLevel, partnerWeighting, utt, context).score(target) - uttCost(utt,params) 
  } else {
    var informativity = expectation(possibleObjects, function(obj) {
      var possibleListenerView = context.concat(obj + '_2');
      return L(partnerLevel, partnerWeighting, utt, possibleListenerView).score(target)
    })
    return (params.alpha * informativity 
            - uttCost(utt,params) 
            - params.perspectiveCost);
  }
}

var S = function(level, target, context) {
  return Infer({method: 'enumerate'}, function() {
    // Agent choosing these
    var utt = uniformDraw(possibleUtterances);
    var egocentricWeighting = level == 0 ? 1 : uniformDraw([0.1, 0.9]); 
    
    // Marginalizing over these
    var partnerLevel = 0;//uniformDraw(_.range(0, level + 1));
    var partnerWeighting = uniformDraw([1]);        
    var perspective = flip(egocentricWeighting) ? 'own' : 'other';
    
    // Weight proportional to utility
    var utility = getSpeakerUtility(perspective, partnerLevel, partnerWeighting,
                                    utt, target, context);
    if(level == 1) {
      print(utt + ',' + partnerWeighting + ',')
      print(utility)      
    }
    factor(utility);
    return {utt, egocentricWeighting};
  });
};
var context = contexts['diff_shape']
// var informativity = expectation(possibleObjects, function(obj) {
//   var possibleListenerView = context.concat(obj + '_2');
//   print(possibleListenerView)
//   viz.table(L(0, 1, 'texture', possibleListenerView))
//   return L(0, 1, 'texture', possibleListenerView).score('texture_color_shape')
// })
// print(informativity)
//viz(L(0, .25, 'texture_color_shape', context.concat(['texture_color_shape_2'])))
//viz.marginals(S(0, 'texture_color_shape', contexts['diff_shape']))
viz.table(S(1, 'texture_color_shape', contexts['diff_shape']))
//viz(S(0, 'texture_color_shape', contexts['diff_shape']))
