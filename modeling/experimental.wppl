///fold:
var possibleUtterances = [
  'shape', 'color', 'texture', 'texture_color', 'color_shape', 'texture_shape', 'texture_color_shape'
];

// hand-coded to match stimulus set used in experiment
var possibleObjects = Categorical({
  vs: ['texture_color_shape', 'otherTexture_color_shape', 'texture_otherColor_shape',
       'otherTexture_otherColor_shape', 'texture_color_otherShape', 'texture_otherColor_otherShape',
       'otherTexture_color_otherShape', 'otherTexture_otherColor_otherShape']
//  ps: [1/64, 3/64, 3/64, 9/64, 3/64, 9/64, 9/64, 27/64]
});

var params = {
  alpha: 10,
  textureCost : 0.01,
  shapeCost : 0.01,
  colorCost : 0.01,
  perspectiveCost : 1
}

var contexts = {
  'diff_shape' : ['texture_color_shape', 'otherTexture_otherColor_otherShape'],
  'shape_only' : ['texture_color_shape', 'otherTexture_otherColor_shape'],
  'color_shape' : ['texture_color_shape', 'otherTexture_color_shape'],
  'texture_shape' : ['texture_color_shape', 'texture_otherColor_shape']
};

var uttFitness = function(utt, object) {
  var descriptors = utt.split('_');
  var objProperties = object.split('_').slice(0,3);
  var matches = _.every(map(function(descriptor) {
    return _.includes(objProperties, descriptor);
  }, descriptors));
  return matches
};

var uttCost = function(utt) {
  var descriptors = utt.split('_');
  return sum(map(function(descriptor) {
    return descriptor == 'null' ? 0 : params[descriptor + 'Cost'];
  }, descriptors));
};
//

var getSpeakerView = function(context) {
  var hiddenObj = find(function(x) {return last(x) == '2';}, context);
  return remove(hiddenObj, context);
};

// Interpret utterance literally using fixed mixture of perspectives
var L0 = function(utt, context, weighting) {
  return Infer({method: 'enumerate'}, function() {
    var perspective = flip(weighting) ? 'other' : 'own';
    var partnerContext = perspective == 'own' ? context : getSpeakerView(context);
    var object = uniformDraw(partnerContext);
    condition(uttFitness(utt, object));
    return object;
  });
};

// Interpret utterance pragmatically using fixed mixture of perspectives.
// Reasons about speaker's weighting.
// var L1 = function(utt, context, weighting) {
//   return Infer({method: 'enumerate'}, function() {
//     var perspective = flip(weighting) ? 'own' : 'other';
//     var partnerContext = perspective == 'own' ? context : getSpeakerView(context);
//     var object = uniformDraw(partnerContext);
//     observe(marginalize(S1(object, context), function(x) {return x.utt}), utt);
//     return object;
//   });
// };

var S1 = function(target, context, ownWeighting, partnerWeighting) {
  return Infer({method: 'enumerate'}, function() {
    // Agent choosing these
    var utt = uniformDraw(possibleUtterances);
        
    // Marginalizing over these
    var perspective = flip(ownWeighting) ? 'other' : 'own';
    
    // Weight proportional to utility
    var informativity = (
      perspective == 'own' ? L0(utt, context, partnerWeighting).score(target) :
        expectation(possibleObjects, function(obj) {
          var possibleListenerView = context.concat(obj + '_2');
          return (L0(utt, possibleListenerView, partnerWeighting).score(target));
        })
    );

    factor(params.alpha * (informativity - uttCost(utt,params)));
    return utt;
  });
};

var S1_RR = function(target, context) {
  return Infer({method: 'enumerate'}, function() {
    var ownWeighting = uniformDraw([0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1]);

    var utility = expectation(possibleObjects, function(obj) {
      return expectation(Categorical({vs: [0, 1]}), function(partnerWeighting) {
        var hypotheticalSelf = S1(target, context, ownWeighting, partnerWeighting);
        var possibleListenerView = context.concat(obj + '_2');
        var utt = MAP(hypotheticalSelf)['val'];
        return L0(utt, possibleListenerView, partnerWeighting).score(target);
      });
    });

    factor(20*(utility - ownWeighting * 0.1))
    return ownWeighting;
  })
}

var context = contexts['diff_shape'];
//console.log(JSON.stringify(S1('texture_color_shape', contexts['diff_shape'], 1)))
console.log(JSON.stringify(S1_RR('texture_color_shape', contexts['diff_shape'])))

// var informativity = expectation(possibleObjects, function(obj) {
//   var possibleListenerView = context.concat(obj + '_2');
//   print(possibleListenerView)
//   viz.table(L(0, 1, 'texture', possibleListenerView))
//   return L(0, 1, 'texture', possibleListenerView).score('texture_color_shape')
// })
// print(informativity)
//viz(L(0, .25, 'texture_color_shape', context.concat(['texture_color_shape_2'])))
//viz.marginals(S(0, 'texture_color_shape', contexts['diff_shape']))
//viz.table(S(1, 'texture_color_shape', contexts['diff_shape']))
//viz(S(0, 'texture_color_shape', contexts['diff_shape']))
